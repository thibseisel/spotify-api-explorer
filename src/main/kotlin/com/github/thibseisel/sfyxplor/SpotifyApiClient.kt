package com.github.thibseisel.sfyxplor

import com.github.thibseisel.api.spotify.*
import io.ktor.client.HttpClient
import io.ktor.client.engine.HttpClientEngine
import io.ktor.client.features.*
import io.ktor.client.features.json.GsonSerializer
import io.ktor.client.features.json.Json
import io.ktor.client.request.*
import io.ktor.http.ContentType
import io.ktor.http.HttpHeaders
import io.ktor.http.HttpStatusCode
import io.ktor.http.URLProtocol
import kotlinx.coroutines.io.ByteReadChannel
import kotlinx.coroutines.io.readUTF8LineTo
import org.jetbrains.annotations.TestOnly
import java.util.*

enum class SearchType {
    ARTIST, ALBUM, TRACK
}

private suspend fun ByteReadChannel.readText(): String = buildString {
    while (!isClosedForRead) {
        readUTF8LineTo(this)
    }
}

class AuthenticationException : Exception()

sealed class SpotifyApiException : Exception()
class AuthenticationRequired : SpotifyApiException()
class ResourceNotFound : SpotifyApiException()
class ExceededRateLimit(val retryAfter: Int) : SpotifyApiException()
class UnexpectedCallFailure(val status: HttpStatusCode, override val message: String?) : SpotifyApiException()

interface SpotifyApiClient {

    /**
     * Create an access token for the given [clientId] and keep it until it is expired.
     * Calls to other APIs of this class will use the generated token.
     *
     * @param clientId The public identifier of the client application.
     * This identifier is generated by Spotify on the developer dashboard.
     * @param clientSecret The secret key for the specified client.
     *
     * @return The token that has been generated.
     * @throws AuthenticationException If the provided [clientId] and/or [clientSecret] are invalid credentials.
     */
    suspend fun authenticate(clientId: String, clientSecret: String): AuthToken

    suspend fun search(query: String, type: SearchType): Paging<SearchableResource>

    suspend fun getArtist(id: String): Artist
    suspend fun getSeveralArtists(ids: List<String>): List<Artist>
    suspend fun getArtistAlbums(artistId: String): Paging<Album>
    suspend fun getAlbum(id: String): Album
    suspend fun getSeveralAlbums(ids: List<String>): List<Album>
    suspend fun getAlbumTracks(albumId: String): Paging<Track>
    suspend fun getTrack(id: String): Track
    suspend fun getSeveralTracks(ids: List<String>): List<Track>
    suspend fun getSeveralTrackFeatures(trackIds: List<String>): List<AudioFeatures>
    suspend fun getTrackFeatures(trackId: String): AudioFeatures
}

class SpotifyApiClientImpl
@TestOnly constructor(
    engine: HttpClientEngine,
    private var authToken: AuthToken?
) : SpotifyApiClient {

    constructor(engine: HttpClientEngine) : this(engine, null)

    private val authService = HttpClient(engine) {
        Json {
            serializer = GsonSerializer {
                disableHtmlEscaping()
                disableInnerClassSerialization()
            }
        }

        defaultRequest {
            accept(ContentType.Application.Json)
            url {
                protocol = URLProtocol.HTTPS
                host = "accounts.spotify.com"
                encodedPath = "/api/token"
                parameter("grant_type", "client_credentials")
            }
        }
    }

    private val spotifyService = HttpClient(engine) {
        Json {
            serializer = GsonSerializer {
                disableHtmlEscaping()
                disableInnerClassSerialization()

                registerTypeAdapterFactory(SearchableAdapterFactory())
                registerTypeAdapter(MusicalMode::class.java, MusicalModeJsonAdapter())
                registerTypeAdapter(Pitch::class.java, SpotifyPitchJsonAdapter())
            }
        }

        defaultRequest {
            accept(ContentType.Application.Json)
            url {
                protocol = URLProtocol.HTTPS
                host = "api.spotify.com"
            }

            authToken?.let { (token, _) ->
                header(HttpHeaders.Authorization, "Bearer $token")
            }
        }

        HttpResponseValidator {
            throwOnHttpError()
        }
    }

    private fun HttpCallValidator.Config.throwOnHttpError() = validateResponse { response ->
        when (val status = response.status) {
            HttpStatusCode.Unauthorized -> throw AuthenticationRequired()
            HttpStatusCode.NotFound -> throw ResourceNotFound()
            HttpStatusCode.TooManyRequests -> {
                val retryDelaySeconds = response.headers[HttpHeaders.Authorization]?.toIntOrNull() ?: 0
                throw ExceededRateLimit(retryDelaySeconds)
            }

            else -> if (status.value > 400) {
                val responseContent = response.content.readText()
                throw UnexpectedCallFailure(response.status, responseContent)
            }
        }
    }

    override suspend fun authenticate(clientId: String, clientSecret: String): AuthToken {
        val base64Key = Base64.getEncoder().encodeToString("$clientId:$clientSecret".toByteArray())

        return authService.post<AuthToken> {
            header(HttpHeaders.Authorization, "Basic $base64Key")
        }.also { authToken = it }
    }

    override suspend fun search(query: String, type: SearchType): Paging<SearchableResource> = spotifyService.get {
        url {
            encodedPath = "v1/search"
            parameter("q", query)
            parameter("type", type.name.toLowerCase())
        }
    }

    override suspend fun getArtist(id: String): Artist = spotifyService.get {
        url { path("v1/artists", id) }
    }

    override suspend fun getSeveralArtists(ids: List<String>): List<Artist> = spotifyService.get {
        url { encodedPath = "v1/artists" }
    }

    override suspend fun getArtistAlbums(artistId: String): Paging<Album> = spotifyService.get {
        url { path("v1/artists", artistId, "albums") }
    }

    override suspend fun getAlbum(id: String): Album = spotifyService.get {
        url { path("v1/albums", id) }
    }

    override suspend fun getSeveralAlbums(ids: List<String>): List<Album> = spotifyService.get {
        url { encodedPath = "v1/albums" }
    }

    override suspend fun getAlbumTracks(albumId: String): Paging<Track> = spotifyService.get {
        url { path("v1/albums", albumId, "tracks") }
    }

    override suspend fun getTrack(id: String): Track = spotifyService.get {
        url { path("v1/tracks", id) }
    }

    override suspend fun getSeveralTracks(ids: List<String>): List<Track> = spotifyService.get {
        url { encodedPath = "v1/tracks" }
    }

    override suspend fun getTrackFeatures(trackId: String): AudioFeatures = spotifyService.get {
        url { path("v1/audio-features", trackId) }
    }

    override suspend fun getSeveralTrackFeatures(trackIds: List<String>): List<AudioFeatures> = spotifyService.get {
        url { encodedPath = "v1/audio-features" }
    }

    private suspend inline fun <reified T : Any> issueRequest(block: HttpRequestBuilder.() -> Unit): T = try {
        spotifyService.get(block = block)
    } catch (requestFailure: ClientRequestException) {
        val response = requestFailure.response
        when (val httpStatus = requestFailure.response.status) {
            HttpStatusCode.Unauthorized -> throw AuthenticationRequired()
            HttpStatusCode.TooManyRequests -> {
                val retryDelaySeconds = response.headers[HttpHeaders.RetryAfter]?.toIntOrNull() ?: 0
                throw ExceededRateLimit(retryDelaySeconds)
            }

            else -> throw UnexpectedCallFailure(httpStatus, requestFailure.message)
        }
    } catch (unexpectedFailure: ResponseException) {
        throw UnexpectedCallFailure(unexpectedFailure.response.status, unexpectedFailure.message)
    }
}